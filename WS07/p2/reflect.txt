///////////////////////////////////////////////////////////////////////////
                               Reflection
                             Workshop - #7
Full Name  : Kiet Dung Truong
Student ID#: 122088230

Authenticity Declaration:
I declare this submission is the result of my own work and has not been
shared with any other student or 3rd party content provider. This submitted
piece of work is entirely of my own creation.
///////////////////////////////////////////////////////////////////////////
1.If structures were not used in this workshop, this would impact how you manage the data. To help contrast the differences, first:a)Copy the structure definitions from your code into this file then,b)Copy the variable declaration section of your code into this file.Now, revise the code for only for the variable declaration section (b) above, to demonstrate what you would have to do to make your solution work without structures.

ANSWER: 
a. struct playerInfo
{
    int lives, treasureFound;
    char playerName;
    int enteredPosition[maximumPathLength];
};
struct gameInfo
{
    struct playerInfo player;
    int pathLength, numberOfMoves;
    int bombs[maximumPathLength], buriedTreasure[maximumPathLength];
};

b.    
    int playerLives, playerTreasureFound;
    char playerName;
    int playerEnteredPosition[maximumPathLength];

    int gamePathLength, gameNumberOfMoves;
    int gameBombs[maximumPathLength];
    int gameBuriedTreasure[maximumPathLength];
2.Parallel arrays were used in this workshop. Identify the parallel arrays (refer to your code) and, explain the relationship between these arrays and how they contributed to your solution.

ANSWER:
Parallel array in my code: 
game.buriedTreasure[i],game.bombs[i], player.enteredPosition[i]. 
They are used to keep track and update the game status. 
When the player makes a move to a certain position, the program can check game.bombs[i] and game.buriedTreasure[i] to determine if there's a bomb or treasure at that position. And then, player.enteredPosition[i] is updated to mark that the player has visited that position.3.Examine your part-2 code and identify the line number where the first deepest nested statement is located. Copy this statement into this file. Provide an explanation of the complete logic required to lead for that statement to be executed 

ANSWER:
do 
{
  	if (v_Count == 0)
        {
           
        }
        else
        {
            printf("  ");
            for (i = 0; i < game.pathLength; i++)
            {
                if (currentPosition[i] == 'V')
                {
                    printf("%c\n", currentPosition[i]);
                 }
            }
	}
} while (remainingLives >= 0 && remainingMove >= 0);

It is an if-else condition under do-while loop, which ends when remainingLives == 0 || remainingMove == 0. 
Inside else, there is a printf statement which is nested inside the for loop. The nested for loop iterates over the game path represented by game.pathLength. It checks each position along the path (currentPosition[i]) to see if it equals 'V', indicating the player's current position. If the condition currentPosition[i] == 'V' is true for any position i, the program prints 'V'.